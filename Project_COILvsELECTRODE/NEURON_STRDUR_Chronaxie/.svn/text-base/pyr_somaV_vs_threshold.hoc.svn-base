// goodwin_AmatrudoWeaverPFC_mod_V_sci.hoc
// Modified by Brian Goodwin
// See 'Google Drive/Project_NEURON_MODEL/AmatrudoWeaver_ModelFlowDiagram.gdraw'
//
// Edit Dates:
// 2013-05-22 - see ./parallelcomp_hack_hocfiles/*_core*.hoc
// 2013-06-26 - v2
// 2013-07-01 - v3 (codenamed "runlocal")
// 2013-07-11 - v4.2
// 2013-07-11 - v5
// 2013-08-22 - v6 (working version)
/* 
 v2
 This file is made for running on pere. i.e. it will only run one simulation
 at a time and gets the input file from a specified directory that is on
 pere.mu.edu in ~/modified_amatrudo_goodwin/nrniv_inout_#nrns_[date]/*_nrniv_input*.txt
 
 v3
 This version was made for running on the local nrniv environment. It will 
 use local files to run. This version runs 
 
 v4.2
 This version incorporates the axon and a new FEM input file contained in
 ./fem_examples_in/. Also, this file works on eliminating end effects that
 are observed at low amplitudes, which initiate an action potential at the 
 last node in the axon. The AP then propagates up the axon causing a false
 positive AP to initiate in the soma. The edits for this are primarily in
 "add_axon.hoc" and "init_model.hoc".
 
 v5
 Works on trying to directly modify the last node in the axon to prevent
 end effects. Also, made minor edits on exporting data in an efficient way.
 
 v6
 Exports data in binary form, which is much more efficient and less memory 
 intensive, resulting in ease of data transfer from server to local computer.
 Use of .vwrite(file object) has replaced .printf(file object,format). This 
 has been applied only to writing the vout files.
 
 v7
 Has been modified to run on the SCI cluster.
 */

load_file("nrngui.hoc")

load_file("cell_topology.hoc")
load_file("add_axon.hoc")
load_file("init_model.hoc")
	
// Need to define fnum to run on local machines:
//fnum=5 // Threshold result for # 5:[310.996270,437.887091] (i.e. [ms200,msrapid])

//add axon and morphologic settings
init_model()
add_axon() // make sure n_axon_seg=100 in "add_axon.hoc"
//remove_axon() // bdg 2013

proc model_globals() {
	tstop=35	//msec//
	dt=0.01		//msec//
	steps_per_ms=100 // DO NOT ERASE.  This forces Neuron to use the dt specified
}
model_globals()

/*******  Function for adjusting dendrite length/diam to account for spines *****/
/*  Modified from Patrick Coskren's code.                                       */

ApicalHeadDiam = .47
ApicalHeadLen = .71
ApicalNeckDiam = .19
ApicalNeckLen = .44
BasalHeadDiam = .56
BasalHeadLen = .82
BasalNeckDiam = .16
BasalNeckLen = .54

SurfaceAreaOneApicalSpine = (ApicalNeckDiam * PI * ApicalNeckLen + \
                             ApicalHeadDiam * PI * ApicalHeadLen)
SurfaceAreaOneBasalSpine = (BasalNeckDiam * PI * BasalNeckLen + \
                            BasalHeadDiam * PI * BasalHeadLen)

/* Process: applySubtreeConstantSpineDensity()
 * Adds spines to a cell on all dendrites that are part of the specified SectionList.
 * pattern. The global variable flag_spines is ignored, since this method only makes sense
 * to call when spine processing is desired.
 *
 * Arguments:
 * $o1: SectionList to loop over
 * $2:  Surface area of a single spine
 * $3:  spine density for branches in the SectionList
 *
 *  written by Christina Weaver, 2012-01
 */
proc applySubtreeConstantSpineDensity() { local total_surface_area, dend_surface_area, \
    surface_area_one_spine, surface_area_all_spines, spine_dens, mean_diam
    
    // Ensure that NEURON evaluates the cell in 3D mode when calling diam(), by
    // using a side effect of the area() call.  It doesn't matter which section
    // is used for the call, and the return value of area() can be discarded.
    forall {
        area(0.5)
    }
    
    // This used to be at the end of the function.  I'm trying to move it to the
    // top, where it makes more sense, since the for(x) construct gets used to
    // do the spine adjustment.
    geom_nseg(100, 0.1)  // nseg according to frequency
    forall {
        nseg *= 9
    }
    
    surface_area_one_spine = $2
    spine_dens = $3
    dendrite_count = 0
    total_surface_area = 0
    forsec $o1 {
        
        dendrite_count = dendrite_count + 1
        temp = area(0.5)
        num_spines = L * spine_dens
        
        dend_surface_area = 0
        mean_diam = 0
        for (x) {
            dend_surface_area = dend_surface_area + area(x)
            if( x > 0 && x < 1 )  mean_diam += diam(x)
		}
        mean_diam /= nseg
        total_surface_area = total_surface_area + dend_surface_area
        
        // adjusted by Christina Weaver, 5 Jan 12.  Still some error, but better than using
        // Patrick's method which sets the diam throughout the section to whatever it is in the
        // middle of the section.
        //
        if (dend_surface_area > 0 && num_spines > 0) {
            surface_area_all_spines = (surface_area_one_spine * num_spines)
            factor = (dend_surface_area + surface_area_all_spines) / dend_surface_area
            L = L * (factor^(2/3))
            diam = mean_diam * (factor^(1/3))
        }
    }
    printf("Dendrite_count: %d\n", dendrite_count)
    printf("total surface area before spine correction: %f\n", total_surface_area)
}


// The following functions could be really useful... - bdg 2013-06-10

///*******  Functions for computing firing rates  *******/
//// I left these functions in for help with future debugging - bdg 2013-05-22
//// set_dataVec(), calcFR_bounds(),
//objref spiketimes, apc, isi, fr, ihold
//proc set_dataVec() {
//    spiketimes = new Vector()
//    apc = new APCount(0.5)
//    apc.record(spiketimes)
//    apc.n
//}
//
//// The following functions could be really useful... - bdg 2013-06-10
///********************************************************
// FR == Firing Rate
// calcFR_bounds()
//
// calculate the mean FR and CV during a specified time
// window.
//
// input
// float $1    left endpoint of time window
// float $2    right endpoint of time window
//
// ********************************************************/
//func calcFR_bounds() { local k, tmx
//
//    objref isi, fr
//
//    isi = new Vector()
//    fr = new Vector()
//
//    for( k = 0; k < apc.n-1; k = k+1 ) {
//        if( spiketimes.x[k] >= $1 && spiketimes.x[k+1] <= $2) {
//            isi.append(spiketimes.x[k+1]-spiketimes.x[k])
//            fr.append(1000/isi.x[isi.size-1])
//        }
//    }
//
//    if( fr.size == 0 ) {
//        printf("Found %d spikes; FR mean = 0, stdev 0, CV 0\n",apc.n)
//        return 0.0
//    }
//    if( fr.size > 2 ) {
//        print "FR mean = ", fr.mean, " stdev ",fr.stdev, " CV ", fr.stdev/fr.mean
//    } else { printf("Found %d spikes; FR mean = %.1f\n",apc.n,fr.mean) }
//
//    return fr.mean
//}

/*******  Functions to alter model parameters throughout the cell *******/
proc scaleNa() {
    soma gbar_na = $1
    forsec dendritic gbar_na = $1
    forsec axSame  gbar_na = $1
    forsec axExcit gbar_na = $1*$2
}

proc scaleKV() {
    forall {
        if(ismembrane("kv") )  gbar_kv = $1
	}
    forsec axExcit  gbar_kv = $1*$2
}

proc scale_gpas() {
    forall {
        ifsec "node" continue
        g_pas = $1
    }
}

proc scale_cm() {
    forall {
        cm = $1
        ifsec "node" cm = 0.4 * $1
    }
}

proc set_epasNG() {
    forall e_pas = -1*$1
}

PFC_effective_ApicalSpineDensity = 0.83524895	//  total of 5891 spines, divided by total apical length of 7052.987 microns
PFC_effective_BasalSpineDensity  = 1.1177593	//  total of 4014 spines, divided by total basal  length of 3591.1131 microns

applySubtreeConstantSpineDensity(apical, SurfaceAreaOneApicalSpine, PFC_effective_ApicalSpineDensity)
applySubtreeConstantSpineDensity(basal,  SurfaceAreaOneBasalSpine,  PFC_effective_BasalSpineDensity)
geom_nseg(100,0.1)

// Using SEClamp, as recommended on the NEURON User Forum.  See init_PFC.hoc for details.
INITDUR = 80

distance()

objref synBranches, synLoc
// Parameter settings
VO = -70
V0 = -70 //avoid ambiguity of "Capital O" vs "zero 0"

// The biophys behind these scalings I'm not quite sure of - BDG 2013-05-22
set_epasNG(69)
scale_gpas(3.8e-5)
scaleNa(105,1e3)
scaleKV(115,16.6667)

forall { if( ismembrane("na") )   vshift_na=-10.5 }

forall { v_init = -70 }

// deleted "copied from synTweak.hoc in ~/LuebkeAmatrudo_forCluster" - BDG 2013-05-22

///////////////////////////////////////////////////
//////////////// FINDING THRESHOLD ////////////////
///////////////////////////////////////////////////
/*
 The following code should include a threshold finder for the Magstim Rapid
 waveform and the TMS Magstim 200 waveform. Note that the Magstim Rapid has
 an amplitude of [0.6*(Magstim 200)]. This can be incorproated into the
 experiments.
 
 This code may need to include an AP counter for other sections of the model.
 It seems that it is possible for the dendritic field to initiate an AP without
 the soma initiating an AP.
 */

// Set AP counter
objref apc
soma {
    apc=new APCount(.5)
    apc.thresh=0
}

// Make fnum the IClamp amplitude
// fnum = .005
// fnum = .05
// fnum = .1
 fnum = .125
// fnum = 0.13
// fnum =.14
// fnum = .15
// fnum = .2
// fnum = .25
// fnum = .3
// fnum = .35

// Add IClamp to increase soma V (Try on dendrites as well?)
objref iclmp
soma {
    iclmp = new IClamp(.5)
    iclmp.dur = 8
    iclmp.del = 2
	iclmp.amp = fnum

}

// Both "trial()" and "threshold()" work together.
func trial() {
	stenvar = $1
	knob_amp = stenvar //Vstim = stenvar
	finitialize()
	fcurrent()
	run()
    
	if (apc.n > 0) {
		return 1
    }
	return 0
}

epsilon = 0.01
func threshold() {
	lbound = 500 // helps model converge with good approximation
	ubound = .01
	strength = 50
	while((abs(lbound-ubound))>(abs(epsilon))) {
		print "strength= ", strength
		excited=trial(strength)
		tstep=0
		last_strength_val=strength
		if(excited>0) {
			lbound = strength
			strength = (ubound+lbound)/2
		} else {
			ubound = strength
			strength = (ubound+lbound)/2
		}
	}
	oldthresh = ubound
	
	print "threshold = ", last_strength_val
    //	f1.printf ("%d\t %f\t %f\n", j, last_strength_val, max_del2v)
	return lbound
}

// ----Threshold function end----//

// The following names can be changed to look at different stimulation configurations.
strdef fem_name, wav_name, outputname, inpathname, outpathname
objref f1

load_file("./extracellular_stim_setup.hoc")

// Editing last node in axon to prevent end effects
// bdg 2013-07-11
/* List of Mechanisms in node[n_axon_seg-1]:
 morphology
 capacitance
 pas
 extracellular
 fastpas
 na_ion
 k_ion
 hh
 kv
 na
 xtra
 */
objref mt
mt = new MechanismType(0) // see http://www.neuron.yale.edu/neuron/static/docs/help/neuron/neuron/classes/mechtype.html
for i=n_axon_seg-10,n_axon_seg-1 {
    node[i] {
        mt.select("fastpas")
        mt.remove()
        mt.select("hh")
        mt.remove()
        mt.select("kv")
        mt.remove()
        mt.select("na")
        mt.remove()
        mt.select("capacitance")
        mt.remove()
    }
    myelin[i] {
        mt.select("fastpas")
        mt.remove()
        mt.select("hh")
        mt.remove()
        mt.select("kv")
        mt.remove()
        mt.select("na")
        mt.remove()
        mt.select("capacitance")
        mt.remove()
    }
}

/*
 Need to setup voltage recording for every relevent node starting
 from t=10ms to about 30ms. This way the files won't be too big.
 */

inpathname =    "./input/"
outpathname =   "./output/"

strdef fempref
//fempref = "v357bi72m1"
fempref = "v3236bi72m1"

// Load voltage input

sprint(fem_name,"%s%s%s",inpathname,fempref,".txt")
fem_load(fem_name)

//////// Magstim 200 Simulations ////////
wav_name = "tms_wave10ms_Magstim200.txt"
wav_load(wav_name)
nrnthreshMS200=threshold()

objref tvec, s

// Make time vector that will trigger the recording vectors to only
// get times from 10ms to 30ms
tvec = new Vector()
tvec.indgen(7,17.5,0.05) // get times from 7:0.05:17.5 ms (chosen by experimentation)

// Record intracellular voltage on all sections
s = new SectionList()
s.wholetree()
numsecs = 0
forsec s numsecs = numsecs+1

objref recvms200[numsecs], recvrapid[numsecs]

for j=0,numsecs-1 {
	recvms200[j]=new Vector()
}
i=0
forsec s {
    recvms200[i].record(&v(0.5),tvec)
    i=i+1
}

knob_amp=nrnthreshMS200
finitialize()
fcurrent()
run()

// Print intracellular voltage recordings
objref vfout
vfout=new File()
sprint(outputname,"%s%s%s%.3f%s",outpathname,fempref,"_monophase_",fnum,".bin")
vfout.wopen(outputname)
for j=0,numsecs-1 {
	recvms200[j].vwrite(vfout)
}
vfout.close()

for j=0,numsecs-1 {recvms200[j].play_remove()}

///////////////////////////////////////////
//////// Magstim Rapid Simulations ////////
wav_name = "tms_wave10ms_MagstimRapid.txt"
wav_load(wav_name)
nrnthreshRAPID=threshold()

for j=0,numsecs-1 {
	recvrapid[j]=new Vector()
}
i=0
forsec s {
    recvrapid[i].record(&v(0.5),tvec)
    i=i+1
}

knob_amp=nrnthreshRAPID
finitialize()
fcurrent()
run()

// Print intracellular voltage recording
objref vfout
vfout=new File()
sprint(outputname,"%s%s%s%.3f%s",outpathname,fempref,"_biphase_",fnum,".bin")
vfout.wopen(outputname)
for j=0,numsecs-1 {
	recvrapid[j].vwrite(vfout)
}
vfout.close()

for j=0,numsecs-1 {recvrapid[j].play_remove()}

///////////////////////////////////////////
////// Writing the threshold values ///////

// Writing threshold outputs
f1=new File()
sprint(outputname,"%s%s%s%.3f%s",outpathname,fempref,"_somaV_vs_thresh_",fnum,".txt")
f1.wopen(outputname)
f1.printf("%.3f %.3f %.3f",fnum,nrnthreshMS200,nrnthreshRAPID)
f1.close()

