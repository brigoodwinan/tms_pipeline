// goodwin_AmatrudoWeaverPFC_mod_runlocal_withaxon.hoc
// Modified by Brian Goodwin
// See 'Google Drive/Project_NEURON_MODEL/AmatrudoWeaver_ModelFlowDiagram.gdraw'
//
// Edit Dates:
// 2013-07-23 - v2
// 2013-08-22 - v2
// 2013-08-22 - v3
// 2014-07-18 - v6 (working version)
//
////// Version Notes //////
/* 
 v2
 Attempting to access the x, y, and z coordinates that have been outputted
 into the vout files from pere... There is a voltage recorder at the middle
 of each section, so this verstion attempts to extract the locations of the
 middle of each section and write it to a text file. Made minor modifations
 to how the data will be exported.
 
 v3
 Makes modifications for how data will be exported. Attempting to export in
 binary format to reduce file sizes. Exporting to binary was a success.
 
 v6
 This version is the equivalent "runlocal" version as the script for running
 on PBS clusters.
 */

load_file("nrngui.hoc")

load_file("cell_topology.hoc")
load_file("add_axon.hoc")
load_file("init_model.hoc")

//add axon and morphologic settings
init_model()
add_axon() // make sure n_axon_seg=100 in "add_axon.hoc"
//remove_axon() // bdg 2013

proc model_globals() {
	tstop=120	//msec//
	dt=0.01		//msec//
	steps_per_ms=100 // DO NOT ERASE.  This forces Neuron to use the dt specified
}
model_globals()

/*******  Function for adjusting dendrite length/diam to account for spines *****/
/*  Modified from Patrick Coskren's code.                                       */

ApicalHeadDiam = .47
ApicalHeadLen = .71
ApicalNeckDiam = .19
ApicalNeckLen = .44
BasalHeadDiam = .56
BasalHeadLen = .82
BasalNeckDiam = .16
BasalNeckLen = .54

SurfaceAreaOneApicalSpine = (ApicalNeckDiam * PI * ApicalNeckLen + \
                             ApicalHeadDiam * PI * ApicalHeadLen)
SurfaceAreaOneBasalSpine = (BasalNeckDiam * PI * BasalNeckLen + \
                            BasalHeadDiam * PI * BasalHeadLen)

/* Process: applySubtreeConstantSpineDensity()
 * Adds spines to a cell on all dendrites that are part of the specified SectionList.
 * pattern. The global variable flag_spines is ignored, since this method only makes sense
 * to call when spine processing is desired.
 *
 * Arguments:
 * $o1: SectionList to loop over
 * $2:  Surface area of a single spine
 * $3:  spine density for branches in the SectionList
 *
 *  written by Christina Weaver, 2012-01
 */
proc applySubtreeConstantSpineDensity() { local total_surface_area, dend_surface_area, \
    surface_area_one_spine, surface_area_all_spines, spine_dens, mean_diam
    
    // Ensure that NEURON evaluates the cell in 3D mode when calling diam(), by
    // using a side effect of the area() call.  It doesn't matter which section
    // is used for the call, and the return value of area() can be discarded.
    forall {
        area(0.5)
    }
    
    // This used to be at the end of the function.  I'm trying to move it to the
    // top, where it makes more sense, since the for(x) construct gets used to
    // do the spine adjustment.
    geom_nseg(100, 0.1)  // nseg according to frequency
    forall {
        nseg *= 9
    }
    
    surface_area_one_spine = $2
    spine_dens = $3
    dendrite_count = 0
    total_surface_area = 0
    forsec $o1 {
        
        dendrite_count = dendrite_count + 1
        temp = area(0.5)
        num_spines = L * spine_dens
        
        dend_surface_area = 0
        mean_diam = 0
        for (x) {
            dend_surface_area = dend_surface_area + area(x)
            if( x > 0 && x < 1 )  mean_diam += diam(x)
		}
        mean_diam /= nseg
        total_surface_area = total_surface_area + dend_surface_area
        
        // adjusted by Christina Weaver, 5 Jan 12.  Still some error, but better than using
        // Patrick's method which sets the diam throughout the section to whatever it is in the
        // middle of the section.
        //
        if (dend_surface_area > 0 && num_spines > 0) {
            surface_area_all_spines = (surface_area_one_spine * num_spines)
            factor = (dend_surface_area + surface_area_all_spines) / dend_surface_area
            L = L * (factor^(2/3))
            diam = mean_diam * (factor^(1/3))
        }
    }
    printf("Dendrite_count: %d\n", dendrite_count)
    printf("total surface area before spine correction: %f\n", total_surface_area)
}


// The following functions could be really useful... - bdg 2013-06-10

///*******  Functions for computing firing rates  *******/
//// I left these functions in for help with future debugging - bdg 2013-05-22
//// set_dataVec(), calcFR_bounds(),
//objref spiketimes, apc, isi, fr, ihold
//proc set_dataVec() {
//    spiketimes = new Vector()
//    apc = new APCount(0.5)
//    apc.record(spiketimes)
//    apc.n
//}
//
//// The following functions could be really useful... - bdg 2013-06-10
///********************************************************
// FR == Firing Rate
// calcFR_bounds()
//
// calculate the mean FR and CV during a specified time
// window.
//
// input
// float $1    left endpoint of time window
// float $2    right endpoint of time window
//
// ********************************************************/
//func calcFR_bounds() { local k, tmx
//
//    objref isi, fr
//
//    isi = new Vector()
//    fr = new Vector()
//
//    for( k = 0; k < apc.n-1; k = k+1 ) {
//        if( spiketimes.x[k] >= $1 && spiketimes.x[k+1] <= $2) {
//            isi.append(spiketimes.x[k+1]-spiketimes.x[k])
//            fr.append(1000/isi.x[isi.size-1])
//        }
//    }
//
//    if( fr.size == 0 ) {
//        printf("Found %d spikes; FR mean = 0, stdev 0, CV 0\n",apc.n)
//        return 0.0
//    }
//    if( fr.size > 2 ) {
//        print "FR mean = ", fr.mean, " stdev ",fr.stdev, " CV ", fr.stdev/fr.mean
//    } else { printf("Found %d spikes; FR mean = %.1f\n",apc.n,fr.mean) }
//
//    return fr.mean
//}

/*******  Functions to alter model parameters throughout the cell *******/
proc scaleNa() {
    soma gbar_na = $1
    forsec dendritic gbar_na = $1
    forsec axSame  gbar_na = $1
    forsec axExcit gbar_na = $1*$2
}

proc scaleKV() {
    forall {
        if(ismembrane("kv") )  gbar_kv = $1
	}
    forsec axExcit  gbar_kv = $1*$2
}

proc scale_gpas() {
    forall {
        ifsec "node" continue
        g_pas = $1
    }
}

proc scale_cm() {
    forall {
        cm = $1
        ifsec "node" cm = 0.4 * $1
    }
}

proc set_epasNG() {
    forall e_pas = -1*$1
}

PFC_effective_ApicalSpineDensity = 0.83524895	//  total of 5891 spines, divided by total apical length of 7052.987 microns
PFC_effective_BasalSpineDensity  = 1.1177593	//  total of 4014 spines, divided by total basal  length of 3591.1131 microns

applySubtreeConstantSpineDensity(apical, SurfaceAreaOneApicalSpine, PFC_effective_ApicalSpineDensity)
applySubtreeConstantSpineDensity(basal,  SurfaceAreaOneBasalSpine,  PFC_effective_BasalSpineDensity)
geom_nseg(100,0.1)

// Using SEClamp, as recommended on the NEURON User Forum.  See init_PFC.hoc for details.
INITDUR = 80

distance()

objref synBranches, synLoc
// Parameter settings
VO = -70
V0 = -70 //avoid ambiguity of "Capital O" vs "zero 0"

// The biophys behind these scalings I'm not quite sure of - BDG 2013-05-22
set_epasNG(69)
scale_gpas(3.8e-5)
scaleNa(105,1e3)
scaleKV(115,16.6667)

forall { if( ismembrane("na") )   vshift_na=-10.5 }

forall { v_init = -70 }

// deleted "copied from synTweak.hoc in ~/LuebkeAmatrudo_forCluster" - BDG 2013-05-22

///////////////////////////////////////////////////
//////////////// FINDING THRESHOLD ////////////////
///////////////////////////////////////////////////
/*
 The following code should include a threshold finder for the Magstim Rapid
 waveform and the TMS Magstim 200 waveform. Note that the Magstim Rapid has
 an amplitude of [0.6*(Magstim 200)]. This can be incorproated into the
 experiments.
 
 This code may need to include an AP counter for other sections of the model.
 It seems that it is possible for the dendritic field to initiate an AP without
 the soma initiating an AP.
 */

// Set AP counter
objref apc
soma {
    apc=new APCount(.5)
    apc.thresh=0
}

// Both "trial()" and "threshold()" work together.
func trial() {
	stenvar = $1
	knob_amp = stenvar //Vstim = stenvar
	finitialize()
	fcurrent()
	run()
    
	if (apc.n > 0) {
		return 1
    }
	return 0
}

epsilon = 0.01
func threshold() {
	lbound = 500 // helps model converge with good approximation
	ubound = .01
	strength = 100 // to aid with converging.
	while((abs(lbound-ubound))>(abs(epsilon))) {
		print "strength = ", strength
		excited=trial(strength)
		tstep=0
		last_strength_val=strength
		if(excited>0) {
			lbound = strength
			strength = (ubound+lbound)/2
		} else {
			ubound = strength
			strength = (ubound+lbound)/2
		}
	}
	oldthresh = ubound
	
	print "threshold = ", last_strength_val
    //	f1.printf ("%d\t %f\t %f\n", j, last_strength_val, max_del2v)
	return lbound
}

// ----Threshold function end----//

// The following names can be changed to look at different stimulation configurations.
strdef fem_name, wav_name, outputname, inpathname, outpathname
objref f1

load_file("./extracellular_stim_setup.hoc")

// Editing last node in axon to prevent end effects
// bdg 2013-07-11
/* List of Mechanisms in node[n_axon_seg-1]:
 morphology
 capacitance
 pas
 extracellular
 fastpas
 na_ion
 k_ion
 hh
 kv
 na
 xtra
 */
objref mt
mt = new MechanismType(0) // see http://www.neuron.yale.edu/neuron/static/docs/help/neuron/neuron/classes/mechtype.html
for i=n_axon_seg-10,n_axon_seg-1 {
    node[i] {
        mt.select("fastpas")
        mt.remove()
        mt.select("hh")
        mt.remove()
        mt.select("kv")
        mt.remove()
        mt.select("na")
        mt.remove()
        mt.select("capacitance")
        mt.remove()
    }
    myelin[i] {
        mt.select("fastpas")
        mt.remove()
        mt.select("hh")
        mt.remove()
        mt.select("kv")
        mt.remove()
        mt.select("na")
        mt.remove()
        mt.select("capacitance")
        mt.remove()
    }
}



/////////// THIS NEED TO BE REMOVED FOR CLUSTER COMPUTING /////////// 
//load_file("gui_for_testing.ses") ////////////////////////////////////
/////////// THIS NEED TO BE REMOVED FOR CLUSTER COMPUTING ///////////

//////
fnum = 20
//////

/*
 Need to setup voltage recording for every relevent node starting
 from t=10ms to about 30ms. This way the files won't be too big.
*/

inpathname =    "/home/collab/bgoodwin/clustering/NEURON_STRDUR_Chronaxie/input/"
outpathname =   "/home/collab/bgoodwin/clustering/NEURON_STRDUR_Chronaxie/output/"

// Load voltage input
sprint(fem_name,"%s%s",inpathname,"bstimfem.txt")
fem_load(fem_name)

///////////////////////////////////////////
//////// stepfunction ////////
sprint(wav_name,"%s%s%d%s",inpathname,"stepfun_",fnum,".txt")
wav_load(wav_name)
nrnthresh=threshold()

///////////////////////////////////////////
////// Writing the threshold values ///////

f1=new File()
sprint(outputname,"%s%s%02d%s",outpathname,"bstimstepthresh",fnum,".txt")
f1.wopen(outputname)
f1.printf("%d %.3f",fnum,nrnthresh)
f1.close()


